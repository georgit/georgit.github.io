<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Teo Georgiev</title>
    <link>https://georgit.github.io/post/index.xml</link>
    <description>Recent content in Posts on Teo Georgiev</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016 Teo Georgiev</copyright>
    <lastBuildDate>Tue, 31 Jan 2017 10:00:00 +0000</lastBuildDate>
    <atom:link href="https://georgit.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Component Forking</title>
      <link>https://georgit.github.io/post/post_02/</link>
      <pubDate>Tue, 31 Jan 2017 10:00:00 +0000</pubDate>
      
      <guid>https://georgit.github.io/post/post_02/</guid>
      <description>&lt;p&gt;True to my word, this is the first post in a long time.
What have I been working on research-wise?&lt;/p&gt;

&lt;p&gt;As some of you know, I&amp;rsquo;m working on the Composite component-based operating system.
More on that can be found &lt;a href=&#34;http://composite.seas.gwu.edu&#34;&gt;here&lt;/a&gt;.
Specifically, my current work is on the shared memory pieces of Composite, and the booter.&lt;/p&gt;

&lt;p&gt;Composite splits the OS into multiple components identified by numbered ids, moving as many as safely possible into user space, leaving only a tiny kernel.
This lets us do some neat things like reboot individual components on failure and provide more security.&lt;/p&gt;

&lt;p&gt;These components are booted up by the booter, which is also a user-level component.
There&amp;rsquo;s another component that provides shared memory to the system in the form of cbufs (Composite buffers).
The booter makes a bunch of these (about a dozen, depending) per component, maps them into its address space, and then kicks the component off.&lt;/p&gt;

&lt;p&gt;I found this interesting in part because of how much it simplified my understanding of what&amp;rsquo;s needed to make a component.
Once you have the component&amp;rsquo;s memory, that&amp;rsquo;s all you need to tell the kernel to get it running (there&amp;rsquo;s also threads, you need threads too).&lt;/p&gt;

&lt;p&gt;What I&amp;rsquo;ve been trying to do is take advantage of this property by building functionality into the booter that lets it duplicate a component.
We call this &amp;ldquo;forking&amp;rdquo;, after the POSIX term, using the notation O for the original component and F for the fork.
Forking a component creates a copy of it with a new id, but in all other ways the same as the original.
The cbuf manager comes in handy here because it can expedite the process by mapping O&amp;rsquo;s cbufs into F.&lt;/p&gt;

&lt;p&gt;The overall process should sound familiar to those readers who&amp;rsquo;ve worked with POSIX, but there are some things we can&amp;rsquo;t mimic, or just haven&amp;rsquo;t gotten around to yet.
Some of these are design choices and some are due to us not using a monolithic system.
The POSIX interface was made in the days of single-core systems and is somewhat hamstrung by assumptions made at the time.
For one, our process tries to hide from the component that it was forked, while POSIX explicitly notifies the child and parent of their identities.&lt;/p&gt;

&lt;p&gt;So now we have a way to take a component O and create a forked copy of it (F).
What does this give us?
Composite could already reboot components, and quite frequently.
So instead of making a copy of the component, couldn&amp;rsquo;t we just reboot it, treating  the suspicious behavior as a failure?
And - although I haven&amp;rsquo;t gone into this in much detail - why not just boot several instances of the same component at the start of execution?
They wouldn&amp;rsquo;t be forks of each other, but you could switch from one to the other.&lt;/p&gt;

&lt;p&gt;One reason is just to provide functionality similar to POSIX.
Another is that with this technique, we can provide continued execution to the system.
There is a brief pause while forking occurs but not while we decide whether or not O was trustworthy.
We can also do n-Modular Redundancy by forking components as existing ones fail.
This is the immediate focus.&lt;/p&gt;

&lt;p&gt;But part of the reason I&amp;rsquo;m working on this is simply because it&amp;rsquo;s fun, not because it has immediate applications.
Research is like that a lot; my work won&amp;rsquo;t be featured in the next quarterly earnings report of any major company.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About this site</title>
      <link>https://georgit.github.io/post/firstPost/</link>
      <pubDate>Wed, 20 Apr 2016 10:00:00 +0000</pubDate>
      
      <guid>https://georgit.github.io/post/firstPost/</guid>
      <description>&lt;p&gt;This is my research site!
I&amp;rsquo;ve always put off making one because I figure everyone who wanted to find me could do so already, and I have no idea what to write about, but now that I&amp;rsquo;m publishing papers, I figure I might as well.
Not sure that there will be a lot of posts here, but I &lt;em&gt;am&lt;/em&gt; sure there will be no Facebook political opinions, since I think we&amp;rsquo;re all tired of those.
Please also note that as my work is in systems, this site is not going to be flashy or fancy.
This is by design.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>